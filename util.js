const assert = require("assert");

// Levels used by columns generated by components.js
const levels = {
  DATABASE: 0,
  COLLECTION: 1,
  DOCUMENT_BASE: 2
};

/**
 * Used for handling errors in async functions called by event handlers.
 * Terminates the program if any error occurs.
 *
 * @param {Screen} screen blessed screen to terminate on error
 * @param {function} fn async function to run
 */
function crashOnError(screen, fn) {
  return () => {
    return fn().catch(e => {
      if (screen) screen.destroy();
      console.error(e);
      return process.exit(1);
    });
  };
}

const colCache = {};

/**
 * Save a column's data, so that it can be loaded at a later time.
 *
 * @param {Column} col
 */
function saveColumn(col) {
  colCache[col.level] = {
    items: col.getItems(),
    selected: col.selected
  };
}

/**
 * Load a previously stored column's data into the specified target.
 *
 * @param {Column} col targets column to load data into
 * @param {Number} level level of the column to load
 */
function loadColumn(col, level) {
  col.setItems(colCache[level].items);
  col.select(colCache[level].selected);
  col.setLevel(level);
}

/**
 * Utility for browsing the contents of a collection.
 */
const browser = {
  docs: {},
  cursor: [],

  load: function(docs) {
    this.docs = {};
    this.cursor = [];
    for (const doc of docs) {
      this.docs[doc._id] = doc;
    }
  },

  traverse: function(level, selection) {
    // depth 0 -> topmost layer of document
    const depth = level - levels.DOCUMENT_BASE;

    if (depth + 2 === this.cursor.length) {
      // we backed out a level, trim the cursor shorter
      this.cursor.pop();
      assert(selection === this.cursor[depth]);
      return this.get();
    }

    if (depth + 1 === this.cursor.length) {
      // we moved to a different branch on the same level
      this.cursor[depth] = selection;
      return this.get();
    }

    // make sure we didn't somehow skip a level otherwise
    assert(depth === this.cursor.length);
    this.cursor.push(selection);

    return this.get();
  },

  get: function(level) {
    const maxDepth =
      level === undefined ? this.cursor.length : level - levels.DOCUMENT_BASE;

    let result = this.docs;
    for (const depth in this.cursor) {
      if (depth > maxDepth) break;
      result = result[this.cursor[depth]];
    }

    return result;
  },

  canAdvance: function() {
    if (!Object.keys(this.docs).length) return false;

    const item = this.get();
    if (Array.isArray(item) || isObject(item)) {
      return true;
    }

    return false;
  }
};

function isObject(obj) {
  return !!obj && typeof obj === "object";
}

module.exports = {
  crashOnError,
  saveColumn,
  loadColumn,
  levels,
  isObject,
  browser
};
